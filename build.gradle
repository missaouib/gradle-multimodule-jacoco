plugins {
    id 'java'
    id 'jacoco'
    id 'idea'
    id 'pl.allegro.tech.build.axion-release' version '1.14.3'
    id 'maven-publish'
    id 'signing'
    id 'base'
}

def isSnapshot = version.toString().endsWith('SNAPSHOT')

allprojects {
    group = 'com.example.productmanagement'

    // Axion Release Plugin (Git-based versioning)
    scmVersion {
        tag {
            prefix = ''
        }
        versionIncrementer 'incrementMinorIfNotOnRelease'
    }
    project.version = scmVersion.version
    println "ðŸ“¦ Project ${project.name} with version: ${project.version}"
    
    repositories {
        mavenCentral()
        jcenter()
        maven { url 'https://repo.spring.io/release' }
        maven { url 'https://repo.spring.io/milestone' }
    }
    
    // Force a specific version of snakeyaml that is available
    configurations.configureEach {
        resolutionStrategy.force 'org.yaml:snakeyaml:1.30'
    }
    
    apply plugin: 'idea'
}

subprojects {
    apply plugin: 'jacoco'
    apply plugin: 'java-library'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    group = rootProject.group
    version = rootProject.version
    
    java {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    
    jacoco {
        toolVersion = "0.8.10" // Updated to the latest version with Java 17+ support
    }
    
    jacocoTestReport {
        reports {
            xml.required = true
            html.required = true
        }
    }
    
    test {
        useJUnitPlatform()
        finalizedBy jacocoTestReport
        
        // Add JaCoCo agent configuration to exclude problematic classes
        jacoco {
            excludes = ['sun.util.resources.cldr.*']
        }
    }

    publishing {
        publications {
            mavenJava(MavenPublication) {
                from components.java
                groupId = project.group
                artifactId = project.name
                version = project.version
            }
        }

        repositories {
            maven {
                def repoUrl = isSnapshot ?
                        "${System.getenv('NEXUS_URL')}/repository/${System.getenv('NEXUS_REPO_SNAPSHOT')}" :
                        "${System.getenv('NEXUS_URL')}/repository/${System.getenv('NEXUS_REPO_RELEASE')}"
                url = uri(repoUrl)

                credentials {
                    username = System.getenv('NEXUS_USERNAME')
                    password = System.getenv('NEXUS_PASSWORD')
                }
            }
        }

        signing {
            def signingKey = System.getenv('GPG_SECRET')
            def signingPass = System.getenv('GPG_PASSPHRASE')
            if (signingKey) {
                useInMemoryPgpKeys(signingKey, signingPass)
                sign publishing.publications
            }
        }
    }
}

// ----------- Changelog Generation Task ----------
task generateChangelog {
    group = 'documentation'
    description = 'Generates a changelog from git logs.'

    doLast {
        def lastTag = 'git describe --tags --abbrev=0'.execute().text.trim()
        def log = "git log ${lastTag}..HEAD --oneline".execute().text
        file('CHANGELOG.md').text = "# Changelog\n\n${log}"
        println "âœ… Changelog generated from ${lastTag}"
    }
}

// ----------- Docker Push to Harbor -------------
task dockerPushToHarbor {
    group = 'docker'
    description = 'Builds and pushes Docker image to Harbor'

    doLast {
        def harborUrl = System.getenv('HARBOR_URL')
        def harborProject = System.getenv('HARBOR_PROJECT')
        def dockerImage = System.getenv('DOCKER_IMAGE_NAME') ?: 'gradle'
        def imageTag = project.version.toString()
        def fullImage = "${harborUrl}/${harborProject}/${dockerImage}:${imageTag}"

        println "ðŸš¢ Building and pushing Docker image: ${fullImage}"

        def cmds = [
                "docker login ${harborUrl} -u ${System.getenv('HARBOR_USERNAME')} -p ${System.getenv('HARBOR_PASSWORD')}",
                "docker build -t ${fullImage} .",
                "docker push ${fullImage}"
        ]

        cmds.each { cmd ->
            println "> ${cmd}"
            def proc = ['bash', '-c', cmd].execute()
            proc.in.eachLine { println it }
            proc.waitFor()
        }
    }
}


// Task to aggregate all unit test JaCoCo reports
task jacocoMergedReport(type: JacocoReport) {
    description = 'Generates an aggregate report from all subprojects unit tests'
    group = 'verification'
    
    dependsOn = subprojects.test
    
    additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories.setFrom files(subprojects.sourceSets.main.output)
    executionData.setFrom files(subprojects.jacocoTestReport.executionData)
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
}

// Task to aggregate all integration test JaCoCo reports (if they exist in modules)
task jacocoMergedIntegrationTestReport(type: JacocoReport) {
    description = 'Generates an aggregate report from all subprojects integration tests'
    group = 'verification'
    
    // We'll only include modules that have integration tests
    def modulesWithIntegrationTests = subprojects.findAll { 
        it.tasks.findByName('integrationTest') != null 
    }
    
    dependsOn = modulesWithIntegrationTests.collect { it.tasks.findByName('integrationTest') }
    
    additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories.setFrom files(subprojects.sourceSets.main.output)
    
    // Collect execution data only from modules with integration tests
    executionData.setFrom files(modulesWithIntegrationTests.collect { 
        it.tasks.findByName('jacocoIntegrationTestReport')?.executionData 
    }).filter { it.exists() }
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    // Only run if there's integration test data
    onlyIf = { !executionData.isEmpty() }
}

// Task that combines unit and integration test coverage
task jacocoFullReport(type: JacocoReport) {
    description = 'Generates an aggregate report from all unit and integration tests'
    group = 'verification'
    
    dependsOn jacocoMergedReport, jacocoMergedIntegrationTestReport
    
    additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories.setFrom files(subprojects.sourceSets.main.output)
    
    // Collect execution data from both unit and integration tests
    executionData.setFrom files(jacocoMergedReport.executionData, jacocoMergedIntegrationTestReport.executionData)
    
    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }
    
    // Skip this task if integration test data doesn't exist
    onlyIf = { 
        jacocoMergedReport.executionData.files.size() > 0 ||
        jacocoMergedIntegrationTestReport.executionData.files.size() > 0 
    }
}

idea {
    module {
        downloadJavadoc = true
        downloadSources = true
    }
}
